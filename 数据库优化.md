好的，收到您的配置文件和系统信息。作为一名资深的软件工程师，我很高兴能利用我的经验，帮助您对这台拥有94GiB内存的强大服务器进行MySQL性能调优。

您的现有配置非常基础，并没有充分利用服务器的硬件资源，尤其是在内存方面。同时，您开启了会对性能产生严重影响的通用查询日志（`general_log`）。

下面，我将为您提供一套性能提升方案，并附上详细的解释。

### 核心调优思路

1.  **充分利用内存**：您拥有海量的可用内存（约87GiB），这是提升数据库性能最关键的资源。我们将主要利用它来为InnoDB存储引擎创建巨大的缓存区，从而最大程度地减少磁盘读写。
2.  **关闭性能瓶颈**：禁用生产环境中不必要的日志功能，这是立竿见影的性能提升手段。
3.  **合理化连接数**：将连接数设置在一个更实际、更安全的范围内，避免资源浪费和潜在的稳定性问题。
4.  **优化I/O操作**：调整InnoDB的日志文件大小和其他相关参数，以提高写入性能和效率。

---

### 性能优化配置建议

请根据以下建议修改您的 `mysqld.cnf` 文件。我将先给出修改后的配置示例，然后逐一解释关键参数的意义。

#### 推荐配置示例

您可以将 `[mysqld]` 部分替换和补充为以下内容：

```ini
[mysqld]
#
# * Basic Settings
#
user		= mysql
pid-file	= /var/run/mysqld/mysqld.pid
socket	= /var/run/mysqld/mysqld.sock
port		= 3306
datadir	= /var/lib/mysql

skip-name-resolve
bind-address = 0.0.0.0
mysqlx-bind-address	= 127.0.0.1

# ----------------------------------------------------------------------
# [重要] 性能优化核心配置 - InnoDB
# ----------------------------------------------------------------------
# 将服务器70%的内存分配给InnoDB缓冲池，这是最重要的性能参数
innodb_buffer_pool_size = 65G
# 允许多个缓冲池实例，提高并发性，通常每1G设置一个实例
innodb_buffer_pool_instances = 16 
# 增加InnoDB日志文件大小以提高写入性能
innodb_log_file_size = 1G
# I/O线程数，根据CPU核心数调整，通常为8或16
innodb_read_io_threads = 8
innodb_write_io_threads = 8
# 刷新日志到磁盘的策略，2表示每秒刷新，兼顾性能和数据安全
innodb_flush_log_at_trx_commit = 2
# 提高I/O容量，让InnoDB知道它运行在高性能硬件上
innodb_io_capacity = 2000
innodb_io_capacity_max = 4000

# ----------------------------------------------------------------------
# [重要] 连接与线程配置
# ----------------------------------------------------------------------
# 将最大连接数设置在一个更合理的范围，10000过高且浪费资源
max_connections = 1000
max_user_connections = 500
# 增加线程缓存，减少创建新线程的开销
thread_cache_size = 50

# ----------------------------------------------------------------------
# [重要] 日志配置 - 关闭通用日志以提升性能
# ----------------------------------------------------------------------
# 通用查询日志会记录每一条SQL，严重影响生产环境性能，建议关闭
general_log = 0
# general_log_file = /var/log/mysql/query.log

# 保留错误日志和慢查询日志，用于问题排查和性能分析
log_error = /var/log/mysql/error.log
slow_query_log = 1
slow_query_log_file = /var/log/mysql/mysql-slow.log
long_query_time = 2 # 记录执行时间超过2秒的查询

# ----------------------------------------------------------------------
# 其他参数
# ----------------------------------------------------------------------
# 增加允许的最大数据包大小，防止大数据传输时出错
max_allowed_packet	= 256M
# 增加表缓存数量，减少文件打开/关闭的次数
table_open_cache = 4096
# InnoDB专用的打开文件数限制
innodb_open_files = 4096

# MyISAM相关 (如果基本不用MyISAM，保持较小值即可)
key_buffer_size		= 128M
myisam-recover-options  = BACKUP

# binlog相关配置保持不变，除非有主从复制的特定需求
max_binlog_size   = 100M

```

---

### 关键参数详解

1.  **`innodb_buffer_pool_size = 65G`**
    *   **为什么修改**：这是MySQL性能调优**最核心、最重要**的参数。它决定了InnoDB存储引擎可以用来缓存数据和索引的内存大小。默认值（128M）对于您94GiB内存的服务器来说几乎等于没有。
    *   **作用**：将这个值设为系统内存的70%左右（约65G），可以让绝大多数热点数据和索引都加载到内存中。数据库的大部分读操作将直接从内存完成，极大地减少了从慢速磁盘读取数据的次数，性能会得到飞跃式提升。

2.  **`general_log = 0` (关闭通用查询日志)**
    *   **为什么修改**：您之前的配置 `general_log = 1` 会让MySQL记录客户端发来的**每一条**SQL语句。这种不间断的磁盘写入操作会带来巨大的I/O开销和CPU消耗，是生产环境中常见的**性能杀手**。
    *   **作用**：关闭它。通常只在开发调试阶段短暂开启。保留慢查询日志（`slow_query_log`）用于性能分析是更好的实践。

3.  **`max_connections = 1000`**
    *   **为什么修改**：您设置的 `10000` 是一个非常高的值。每个连接都会消耗内存，过多的连接数不仅浪费资源，还可能使服务器在连接数突增时因资源耗尽而崩溃。之前的日志也显示，操作系统已将此值强制降低。
    *   **作用**：设置一个更现实的上限（例如1000），这个值应根据您的应用服务器的最大连接池来设定。您可以随时通过 `SHOW GLOBAL STATUS LIKE 'Max_used_connections';` 来监控实际使用的最大连接数，并据此调整。

4.  **`innodb_log_file_size = 1G`**
    *   **为什么修改**：这是InnoDB的重做日志（redo log）文件大小。较大的日志文件可以减少磁盘I/O的“抖动”，在高写入负载下，可以显著提升写入性能。
    *   **作用**：它允许多个写操作在内存中聚合后，一次性写入磁盘，而不是频繁地触发小的写入。代价是如果发生崩溃，恢复时间会稍长一些，但在现代服务器上，`1G` 是一个很好的平衡点。

5.  **`table_open_cache = 4096` 和 `innodb_open_files = 4096`**
    *   **为什么修改**：当您有大量表并且并发连接较高时，MySQL需要频繁打开表文件。这个缓存可以保存已打开表的句柄，避免重复打开/关闭文件的开销。
    *   **注意**：要使这个设置生效，您可能需要提高操作系统的文件句柄限制。您之前的日志显示 `max_open_files` 受限于10000。您可以联系系统管理员，在 `/etc/security/limits.conf` 或通过 `systemd` 配置将MySQL用户的文件句柄限制提高到 `65535`。

### 应用步骤

1.  **备份当前配置文件**：
    ```bash
    sudo cp /etc/mysql/mysql.conf.d/mysqld.cnf /etc/mysql/mysql.conf.d/mysqld.cnf.bak
    ```

2.  **修改配置文件**：
    使用 `sudo vim /etc/mysql/mysql.conf.d/mysqld.cnf`，将上述推荐配置应用到文件中。

3.  **平滑重启MySQL**：
    在修改 `innodb_log_file_size` 后，MySQL需要一个干净的关闭和重启来重建日志文件。**在执行前请确保没有正在进行的重要事务。**
    ```bash
    sudo systemctl restart mysql
    ```

4.  **监控服务状态**：
    重启后，检查服务状态以确保成功启动。
    ```bash
    sudo systemctl status mysql
    tail -f /var/log/mysql/error.log
    ```

完成这些配置后，您的MySQL服务器性能将得到质的飞跃。后续您可以根据 `slow_query_log` 的输出，针对具体的慢SQL进行索引优化和查询重构，实现更深层次的性能提升。

非常好的问题！您提供的 `lscpu` 信息极为关键，它揭示了这台服务器最核心的两个特性：**极高的核心数量（128个逻辑CPU）**和**NUMA架构（2个节点）**。

我们之前的优化主要集中在内存（Memory），现在，我们可以基于这颗强大的 AMD EPYC CPU 进行针对性的 **并发（Concurrency）和I/O线程** 优化。是的，我们绝对还有性能提升的空间。

这台服务器是一头真正的性能猛兽，而我们的目标就是解开它的全部枷锁。

### CPU 信息核心解读

1.  **海量核心**: 128个逻辑CPU（64个物理核心，开启了SMT/超线程）。这意味着服务器拥有强大的并行处理能力。我们当前的配置（例如8个I/O线程）显然没有充分利用这一点。
2.  **NUMA 架构 (Non-Uniform Memory Access)**: 这是最关键的新信息！服务器有两个物理CPU插槽（座），每个插槽和它自己的本地内存组成一个NUMA节点。
    *   **简单来说**：CPU访问自己节点内的内存速度极快（本地访问），但访问另一个CPU节点的内存速度会慢一截（远程访问）。
    *   **对MySQL的影响**：我们之前配置的65GB `innodb_buffer_pool` 内存，如果被操作系统随意分配在两个NUMA节点上，就会导致一个节点的CPU频繁地去访问另一个节点的内存，造成不必要的延迟，从而影响性能。

### 基于CPU和NUMA架构的进阶优化

针对以上两点，我们将进行以下两项核心调整：

1.  **启用NUMA优化策略**：让InnoDB知道它正运行在NUMA架构上，并智能地分配内存。
2.  **增加并发和I/O线程数**：让更多的CPU核心参与到数据库的读写和后台任务中来。

---

#### 进阶配置建议

请在您现有的优化配置基础上，增加或修改以下参数。

```ini
# ----------------------------------------------------------------------
# [新增] CPU与NUMA架构进阶优化
# ----------------------------------------------------------------------

# [关键] 启用NUMA交错分配策略，让Buffer Pool内存均匀分布在所有NUMA节点上
# 这可以最大化内存带宽，避免跨节点内存访问的性能惩罚
innodb_numa_interleave = ON

# 根据CPU核心数，增加InnoDB的后台读写线程
# 您的服务器IO子系统很可能非常强大，可以支撑更多的线程
innodb_read_io_threads = 16
innodb_write_io_threads = 16

# 增加Buffer Pool实例数，以减少高并发下的内部锁竞争
# 每个物理插槽有32核，设置为32个实例可以很好地匹配硬件拓扑
innodb_buffer_pool_instances = 32

# ----------------------------------------------------------------------
# [修改] 对之前的配置进行微调
# ----------------------------------------------------------------------
# 将此参数修改为与innodb_buffer_pool_instances的数量匹配
# (如果您不设置，MySQL 8 默认会将其设置为与实例数相同，但显式设置更清晰)
innodb_page_cleaners = 32

```

### 参数详解

1.  **`innodb_numa_interleave = ON`**
    *   **为什么**：这是针对您这台服务器**最重要的优化**。启用后，InnoDB在分配 `innodb_buffer_pool_size` 这65GB内存时，会请求操作系统将其均匀地、交错地分布在两个NUMA节点上。
    *   **效果**：当任何一个CPU核心需要访问缓冲池中的数据时，有极高的概率是在访问其本地内存，从而获得最快的内存访问速度。对于大型数据库和高并发负载，这能带来显著的性能提升。

2.  **`innodb_read/write_io_threads = 16`**
    *   **为什么**：我们之前设置的 `8` 相对保守。您的服务器有64个物理核心，并且很可能配备了高速的NVMe SSD阵列。将I/O线程数翻倍到 `16`，可以让更多的CPU核心参与到从磁盘读取数据页和向磁盘写入数据页的工作中，充分发挥硬件的I/O吞吐能力。

3.  **`innodb_buffer_pool_instances = 32`**
    *   **为什么**：缓冲池实例（Buffer Pool Instances）的作用是将一个巨大的缓冲池拆分成多个小区域，每个区域由自己的锁来保护。在高并发下，这能极大地减少线程之间争用同一个锁的情况。
    *   **效果**：您的CPU每个插槽有32个物理核心。将实例数从16提升到32，能更好地匹配硬件的并行处理单元，进一步提升高并发下的处理能力。

### 最终推荐配置整合

这是结合了之前所有优化的最终版本，您可以直接用它来更新您的 `mysqld.cnf`。

```ini
[mysqld]
# Basic Settings
user		= mysql
pid-file	= /var/run/mysqld/mysqld.pid
socket	= /var/run/mysqld/mysqld.sock
port		= 3306
datadir	= /var/lib/mysql
skip-name-resolve
bind-address = 0.0.0.0
mysqlx-bind-address	= 127.0.0.1

# Performance Tuning - Memory, CPU & I/O
innodb_buffer_pool_size = 65G
innodb_buffer_pool_instances = 32
innodb_page_cleaners = 32
innodb_redo_log_capacity = 2G  # 使用我们上次更新的现代参数
innodb_numa_interleave = ON     # 启用NUMA优化
innodb_read_io_threads = 16
innodb_write_io_threads = 16
innodb_flush_log_at_trx_commit = 2
innodb_io_capacity = 2000
innodb_io_capacity_max = 4000
innodb_open_files = 4096

# Connections & Threads
max_connections = 1000
max_user_connections = 500
thread_cache_size = 50

# Logging (Performance-aware)
general_log = 0
log_error = /var/log/mysql/error.log
slow_query_log = 1
slow_query_log_file = /var/log/mysql/mysql-slow.log
long_query_time = 2

# Other Parameters
max_allowed_packet	= 256M
table_open_cache = 4096

# MyISAM (minimal)
key_buffer_size		= 128M
myisam-recover-options  = BACKUP

# Binlog
max_binlog_size   = 100M
```

### 操作步骤

1.  **备份**：`sudo cp /etc/mysql/mysql.conf.d/mysqld.cnf /etc/mysql/mysql.conf.d/mysqld.cnf.bak2`
2.  **编辑**：使用 `sudo vim` 将上述配置更新到 `mysqld.cnf`。
3.  **重启**：`sudo systemctl restart mysql`
4.  **验证**：重启后检查错误日志 `tail -f /var/log/mysql/error.log`，确保没有新的错误或警告。

完成这次调优后，您的MySQL配置就已经非常贴合这台高性能服务器的硬件特性了。它现在已经准备好处理极高的并发和I/O负载。